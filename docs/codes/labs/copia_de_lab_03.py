# -*- coding: utf-8 -*-
"""Copia de lab_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14KHrS258p-yyq8ZmjtEOut4RQoD5vFRH

<a href="https://colab.research.google.com/github/fralfaro/MAT281/blob/main/docs/labs/lab_03.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>


# MAT281 - Laboratorio N°03

**Objetivo**: Aplicar técnicas avanzadas de manipulación y análisis de datos con pandas sobre un conjunto real de datos de contenido de Netflix, reforzando buenas prácticas y métodos eficientes sin recurrir a `groupby`, `merge`, `pivot`, ni `join`.



**Dataset**:

Trabajaremos con el archivo `netflix_titles.csv`, que contiene información sobre los títulos disponibles en la plataforma Netflix hasta el año 2021.

| Variable       | Clase     | Descripción                                                                 |
|----------------|-----------|------------------------------------------------------------------------------|
| show_id        | caracter  | Identificador único del título en el catálogo de Netflix.                   |
| type           | caracter  | Tipo de contenido: 'Movie' o 'TV Show'.                                     |
| title          | caracter  | Título del contenido.                                                       |
| director       | caracter  | Nombre del director (puede ser nulo).                                       |
| cast           | caracter  | Lista de actores principales (puede ser nulo).                              |
| country        | caracter  | País o países donde se produjo el contenido.                                |
| date_added     | fecha     | Fecha en la que el título fue agregado al catálogo de Netflix.              |
| release_year   | entero    | Año de lanzamiento original del título.                                     |
| rating         | caracter  | Clasificación por edad (por ejemplo: 'PG-13', 'TV-MA').                      |
| duration       | caracter  | Duración del contenido (minutos o número de temporadas para series).        |
| listed_in      | caracter  | Categorías o géneros en los que está clasificado el contenido.              |
| description    | caracter  | Breve sinopsis del contenido.                                               |
"""

import pandas as pd

# Cargar datos
df = pd.read_csv('https://raw.githubusercontent.com/fralfaro/MAT281/main/docs/labs/data/netflix_titles.csv')
df.head()

"""
### Parte 1: Limpieza y preparación

1. Revisar y describir el dataset:

   * ¿Cuántas filas y columnas tiene?
   * ¿Qué tipos de datos hay?
   * ¿Cuántos valores nulos hay por columna?

2. Transformar la columna `date_added` a tipo fecha.

3. Crear columnas auxiliares con `assign`:

   * Año (`year_added`)
   * Mes (`month_added`)

"""

def num_filas_columnas(df):
  filas=df.shape[0]
  columnas=df.shape[1]
  return print(f'El dataset tiene {filas} filas y {columnas} columnas')

def tipos_datos(df):
  return df.dtypes

def valores_nulos(df):
  return df.isnull().sum()


num_filas_columnas(df)
display(tipos_datos(df))
valores_nulos(df)

df['new_date_added']=pd.to_datetime(df['date_added'], errors= 'coerce')
df.head()

df_with_dates = df.assign(
    year_added=df['new_date_added'].dt.year,
    month_added=df['new_date_added'].dt.month
)
df_with_dates.head()

"""## Parte 2: Técnicas avanzadas de pandas

4. Utilizar `.loc` para seleccionar películas (`type == 'Movie'`) que fueron agregadas después del año 2018.

5. Utilizar `str.contains()` y `str.extract()`:

   * Filtrar títulos que contienen la palabra 'love' (sin distinguir mayúsculas/minúsculas).
   * Extraer la duración en minutos para las películas desde la columna `duration`.

6. Aplicar `explode()` sobre la columna `listed_in` para obtener una fila por cada género.

7. Obtener un top 10 de géneros más frecuentes utilizando `value_counts()`.

8. Aplicar `where()` y `mask()` para marcar las películas de más de 120 minutos como contenido largo en una nueva columna.

9. Utilizar `.loc` para filtrar películas que cumplen con:

   * Más de 100 minutos de duración.
   * Rating igual a `'R'`.
   * País igual a `'United States'`.

10. Utilizar `.style` para formatear visualmente el top 10 de películas más largas.
"""

df_new = df_with_dates.loc[(df_with_dates['type']=='Movie') & (df_with_dates['year_added']>2018)].copy()
df_new.head()

df_loveintitle=df_new[df_new['title'].str.contains('love', case=False)]
df_loveintitle.head()

df_new['duration_minutes'] = df_new['duration'].str.extract(r'(\d+)').astype(int) #se hace esto para extraer las decuencias numericas (las cuales se representan por \d+) que estan como string en la duracion del dataset
display(df_new[['title', 'duration', 'duration_minutes']].head())

df_generos = df_new.copy()  #creamos una copia del dataset para poder reconvertir el formato de la columna listed_in para que el .explode funcione bien (esto lo hago porque intente aplicarlo directamente y no separaba todas las categorias de las peliculas, es decir dejaba filas con mas de una categoria)
df_generos['listed_in'] = df_generos['listed_in'].astype(str).str.split(', ') #cambiamos el formato en la copia para no alterar el dataset original
# Aplicar explode() sobre la columna 'listed_in' para obtener una fila por cada género.
df_generos = df_generos.explode('listed_in')

display(df_generos[['title', 'listed_in']].head(10))

top_generos=df_generos['listed_in'].value_counts().head(10)
top_generos

df_new['long_content'] = 'No' # Inicializar la columna con 'No'
df_new['long_content'] = df_new['long_content'].mask(df_new['duration_minutes'] > 120, 'Sí') # Marcar como 'Sí' donde la duración es > 120
df_new.head()

df_peliculas=df.loc[df['type'] == 'Movie'].copy()
df_peliculas['duration_minutes'] = df_peliculas['duration'].str.extract(r'(\d+)').astype(float)
df_filtered = df_peliculas.loc[
    (df_peliculas['duration_minutes'] > 100) &
    (df_peliculas['rating'] == 'R') &
    (df_peliculas['country'] == 'United States')
]
df_filtered

mas_largas=df_peliculas.sort_values('duration_minutes', ascending=False).head(10)
mas_largas.style\
        .background_gradient() #no supe que hacer con el .style

"""

### Pregunta Desafío

11. ¿Cuáles son las combinaciones más frecuentes de género y rating en el dataset?
    (Sugerencia: utilizar `value_counts` con `subset=["genre", "rating"]` después de aplicar `explode()`).



### Bonus: Análisis de duplicados y limpieza

12. ¿Existen películas con el mismo nombre (`title`) pero con distinto año de lanzamiento (`release_year`)?
13. ¿Cuántos títulos únicos hay en total en la columna `title`?



"""

combinaciones_mas_frecuentes = df.value_counts(subset=['listed_in', 'rating']).head(10) #se toma en cuenta el subconjunto de listed in y rating y se cuenta cuales son los que mas se repiten
combinaciones_mas_frecuentes

titulos_duplicados = df[df.duplicated('title', keep=False)].sort_values('title') #buscamos los titulos duplicados con keep=False para no perder ninguno (estuve probando y se perdia uno si no ponia el keep false, por ejemplo si un titulo se repetia 3 veces me entregaba solo 2 de las repeticiones, estas pruebas ls hice sobre la lista de generos ya que en el df original no hay duplicados)
titulos_con_distinto_año= titulos_duplicados.groupby('title').filter(lambda x: x['release_year'].nunique() > 1) #aqui agrupamos todas las peliculas que tienen el mismo titulo y verificamos cuantos años de lanzamientos distintos hay, esto lo hacemos con el .nunique que cuenta cuantos elementos distintos hay
print("Hay", len(titulos_con_distinto_año), "títulos duplicados con años de lanzamiento distintos.")

print("Hay", df['title'].nunique() , "títulos unicos.")

#Como conclusion de hacer esto creo que deberia haberlo hexho xon funciones y creando nuevos data set de vez en cuando ya que me habria facilitado bastante hacer lo solicitado pero bueno pa la proxima