# -*- coding: utf-8 -*-
"""Copia de lab_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WTtdcZmFKV-clWpcWhQXR30xj4ALh6n6

<a href="https://colab.research.google.com/github/fralfaro/MAT281/blob/main/docs/labs/lab_01.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>


# MAT281 - Laboratorio N°01


**Objetivos del Laboratorio**

* Implementar funciones en Python para resolver problemas matemáticos clásicos.
* Aplicar estructuras básicas como ciclos y condicionales en contextos numéricos.
* Comprender y programar conceptos como series, factoriales, divisores, primos y secuencias.
* Desarrollar pensamiento algorítmico y habilidades de resolución estructurada de problemas.

## Problema 01 — Aproximando $\pi$ con una serie infinita

En los siglos XVII y XVIII, los matemáticos **James Gregory** y **Gottfried Leibniz** descubrieron una serie infinita que permite aproximar el valor de $\pi$. Esta serie, conocida como la *serie de Gregory-Leibniz*, se expresa como:

$$
\pi = 4 \sum_{k=1}^{\infty} \frac{(-1)^{k+1}}{2k - 1} = 4\left(1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \cdots\right)
$$

Esta fórmula converge lentamente, pero es útil para entender cómo se puede aproximar un número irracional como $\pi$ mediante una suma finita.

**Tu tarea**

Implementa una **función llamada `calcular_pi(n)`** que reciba como argumento un número entero $n$ e **importe los primeros $n$ términos de la serie** para entregar una aproximación del valor de $\pi$.





**Ejemplos de uso**

```python
calcular_pi(3)     # Resultado esperado: 3.466666...
calcular_pi(1000)  # Resultado esperado: ~3.140592...
```
"""

def calcular_pi(n):
  suma = 0
  for k in range(1,n+1): #hacemos un for que reccore los numeros hasta el numero ingresado y suma en cada iteracion
    suma += (-1)**(k+1)/(2*k-1)
  return 4*suma

calcular_pi(3)

calcular_pi(1000)

"""
## Problema 02 — Aproximando $e$ con la serie de Euler

El número **$e$** es una constante matemática fundamental, al igual que $\pi$. Se encuentra en el corazón del cálculo, el crecimiento exponencial y muchas aplicaciones científicas. Uno de sus grandes impulsores fue **Leonhard Euler**, quien en 1748 publicó su obra *Introductio in analysin infinitorum*, donde describió formalmente la siguiente serie infinita para aproximar su valor:

$$
e = \sum_{k=0}^{\infty} \frac{1}{k!} = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \cdots
$$

Esta fórmula permite calcular $e$ sumando una cantidad finita de términos.



**Tu tarea**

1. **Parte A**: Define una función llamada `factorial(n)` que reciba un número natural $n$ y retorne el valor de su factorial $n! = 1 \cdot 2 \cdot \ldots \cdot n$.

2. **Parte B**: Usando esa función, crea otra función llamada `calcular_e(n)` que reciba un número entero $n$ y devuelva una aproximación del número $e$ sumando los primeros $n$ términos de la serie.



**Ejemplos de uso**

```python
factorial(3)     # Resultado esperado: 6
factorial(5)     # Resultado esperado: 120

calcular_e(3)     # Resultado esperado: 2.666...
calcular_e(1000)  # Resultado esperado: ~2.718281828...
```

"""

def factorial(n):
  if n == 0: #revisamos es caso en que el numero solicitado es 0 ya que el algoritmo no funciona con 0
    return 1
  else:
    resultado=1
    for i in range(2, n + 1): #en caso de no ser cero creamos una variable que recorre todos los enteros entre 2 y el numero ingresado y multiplica la variable en cada iteracion
        resultado *= i
    return resultado

def calcular_e(n):
  suma = 0
  for k in range(0,n+1):#definimos el for para cada valor de la suma hasta el valor del numero ingresado
    suma += 1/factorial(k)
  return suma

factorial(3)

factorial(5)

calcular_e(3)

calcular_e(1000)

"""## Problema 03 — Números amigos y suma de divisores propios

Dado un número natural $n$, se define $\sigma(n)$ como la **suma de sus divisores propios**, es decir, aquellos números positivos menores que $n$ que lo dividen exactamente.

Dos números naturales $n_1$ y $n_2$ se consideran **números amigos** si cumplen la siguiente condición:

$$
\sigma(n_1) = n_2 \quad \text{y} \quad \sigma(n_2) = n_1
$$

Un ejemplo clásico de números amigos es el par $220$ y $284$:

* Los divisores propios de $220$ son: $1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110$, y su suma es $284$.
* Los divisores propios de $284$ son: $1, 2, 4, 71, 142$, y su suma es $220$.

**Tu tarea**

1. **Parte A**: Define una función llamada `divisores_propios(n)` que reciba un número natural $n$ y retorne una **lista** con todos sus divisores propios.

2. **Parte B**: Usando esa función, implementa una función llamada `amigos(n1, n2)` que retorne `True` si los números son amigos y `False` en caso contrario.

**Ejemplos de uso**

```python
divisores_propios(220)  # Resultado esperado: [1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110]
divisores_propios(284)  # Resultado esperado: [1, 2, 4, 71, 142]

amigos(220, 284)        # Resultado esperado: True
amigos(6, 5)            # Resultado esperado: False
```

"""

def divisores_propios(n):
  lista = []
  for i in range(1,(n//2)+1): #Recorremos todos los numeros hasta la mitad del numero ingresado mas 1
    if n % i == 0:#en caso ed que el resto de la division sea 0 lo agregamos a la lista, en caso contrario no
      lista.append(i)
  return lista

def amigos(n1, n2):
  dpn1=divisores_propios(n1) #creamos las listas de los divisores propios de cada numero
  dpn2=divisores_propios(n2)
  sdvpn1=0 #iniciamos una variable para sumar los valores de la lista
  sdvpn2=0
  for i in dpn1:#recorremos cada lista sumando cada termino de la lista a su variable correspondiente
    sdvpn1+=i
  for i in dpn2:
    sdvpn2+=i
  if sdvpn1==n2 and sdvpn2==n1:#comparamos las sumas y determinamos su son amigos o no
    return True
  else:
    return False

divisores_propios(220)

divisores_propios(284)

amigos(220,284)

amigos(6,5)

"""## Problema 04 — La conjetura de Collatz

La [conjetura de Collatz](https://en.wikipedia.org/wiki/Collatz_conjecture), también conocida como **conjetura $3n + 1$** o conjetura de Ulam, fue formulada por el matemático **Lothar Collatz** en 1937. A pesar de su sencillez, aún no ha sido demostrada ni refutada para todos los números naturales.

La conjetura propone la siguiente regla, aplicable a cualquier número entero positivo:

* Si el número es **par**, se divide por 2.
* Si el número es **impar**, se multiplica por 3 y se le suma 1.

Se repite esta operación con cada nuevo número obtenido. La conjetura afirma que, sin importar el número con el que se comience, **eventualmente se alcanzará el número 1**.

**Tu tarea**

Implementa una función llamada `collatz(n)` que reciba como argumento un número natural positivo $n$ y retorne una **lista con la secuencia de valores** generados por la conjetura, hasta llegar a 1.

**Ejemplo de uso**

```python
collatz(9)  
# Resultado esperado:
# [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```


"""

def collatz(n):
  lista=[n]#creamos la lista
  while n!=1:#recorremos creamos un ciclo que se detendra cuando n sea 1
    if n%2==0: #vemos si es par o impar y hacemos lo que dice la conjetura, luego lo agregamos a la lista
      n=n//2
      lista.append(n)
    else:
      n=3*n+1
      lista.append(n)
  return lista

collatz(9)

"""## Problema 05 — La conjetura de Goldbach

La [conjetura de Goldbach](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture) es uno de los problemas abiertos más antiguos y famosos de la teoría de números. Fue formulada por el matemático prusiano **Christian Goldbach** en una carta a Euler en 1742, y plantea lo siguiente:

> **Todo número par mayor que 2 puede escribirse como la suma de dos números primos.**

A pesar de que esta conjetura ha sido verificada para una gran cantidad de números, aún no existe una demostración formal que la confirme para todos los casos posibles.

**Tu tarea**

Implementa una función llamada `goldbach(n)` que reciba un número natural par mayor que 2 y retorne un par de números primos $n_1$ y $n_2$ tales que $n_1 + n_2 = n$.

Para lograrlo, se recomienda dividir el problema en tres partes:

1. **Parte A**: Define una función `es_primo(n)` que reciba un número natural $n$ y retorne `True` si es primo, y `False` en caso contrario.

2. **Parte B**: Define una función `lista_de_primos(n)` que genere una lista con todos los números primos entre 2 y $n$ (inclusive si corresponde).

3. **Parte C**: Utiliza la función anterior dentro de `goldbach(n)` para encontrar dos primos cuya suma sea igual a $n$. Puedes retornar el primer par que cumpla esta condición.

**Ejemplos de uso**

```python
es_primo(3)         # Resultado esperado: True
es_primo(4)         # Resultado esperado: False

lista_de_primos(4)  # Resultado esperado: [2, 3]
lista_de_primos(6)  # Resultado esperado: [2, 3, 5]
lista_de_primos(8)  # Resultado esperado: [2, 3, 5, 7]

goldbach(4)         # Resultado esperado: (2, 2)
goldbach(6)         # Resultado esperado: (3, 3)
goldbach(8)         # Resultado esperado: (3, 5)
```



"""

def es_primo(n):
  for i in range(2,(n//2)+1): #recorremos todos los numeros entre 2 y la mitad del numero ingresado
    if n%i==0:#revisamos si alguno de los valores lo divide, si es asi retornamos falso
      return False
  return True

def lista_de_primos(n):
  lista=[]
  for i in range(2,n+1):#recorremos todos los numeros hasta el numero ingresado
    if es_primo(i):#en caso de que sea primo lo agregamos a la lista
      lista.append(i)
  return lista

def goldbach(n):
  lista=lista_de_primos(n)#creamos la lista de primos hasta el numero ingresado
  for i in lista:#recorremos la lista
    for j in lista:#recorremos la lista de nuevo
      if i+j==n:
        return [i,j]
  return "el numero es impar o encontraste un numero que rompe la conjetura :p"

es_primo(3)

es_primo(4)

lista_de_primos(4)

lista_de_primos(6)

lista_de_primos(8)

goldbach(4)

goldbach(6)

goldbach(8)